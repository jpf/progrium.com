<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>Jeff Lindsay</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/blog/atom.xml" />
    <link rel="shortcut icon" type="image/x-icon" href="/images/JeffLindsayDeluxe.png" />
    <link href='http://fonts.googleapis.com/css?family=Dosis:400,300,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto+Condensed:400,300,700|Lora:400,700,400italic|Vollkorn:400,700' rel='stylesheet' type='text/css'>
    <link href="/stylesheets/all.css" rel="stylesheet" />
  </head>
  <body>
  <div id="wrapper">

    <header>
  <div class="container">
  <div class="row">
      <div class="col-lg-8 col-lg-offset-1">
        You're reading the blog of Jeff Lindsay (<a href="http://twitter.com/progrium">@progrium</a>). There is also his <a href="/wiki">wiki</a>.
      </div>
  </div>
</div>
</header>

<main id="main" role="main">
  <?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>progrium :: Jeff Lindsay</title>
  <subtitle>Pragmatic idealist. Thought explorer.</subtitle>
  <id>http://progrium.com/blog</id>
  <link href="http://progrium.com/blog"/>
  <link href="http://progrium.com/blog/atom.xml" rel="self"/>
  <updated>2015-12-04T16:58:00+00:00</updated>
  <author>
    <name>Jeff Lindsay</name>
    <email>progrium+feed@gmail.com</email>
  </author>
  <entry>
    <title>Leadership, Guilt, and Pull Requests</title>
    <link rel="alternate" href="http://progrium.com/blog/2015/12/04/leadership-guilt-and-pull-requests/"/>
    <id>http://progrium.com/blog/2015/12/04/leadership-guilt-and-pull-requests/</id>
    <published>2015-12-04T16:58:00+00:00</published>
    <updated>2016-02-13T15:49:55+00:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;I have a lot of &lt;a href="https://github.com/progrium?tab=repositories"&gt;open source projects&lt;/a&gt;. Even more with &lt;a href="https://github.com/gliderlabs?tab=repositories"&gt;Glider Labs&lt;/a&gt;. Some of them are fairly popular. All of them get me excited. But most of them also bum me out. I'm going to share one of the reasons I've had to take a break for the past couple months, and why all my repositories are now looking for more maintainers.&lt;/p&gt;

&lt;p&gt;Open source is hard. It seems easy, though. You just write a piece of software and put it on Github, right? Well that was the easy part. Now comes maintenance. And very likely politics. Inevitably, guilt. Multiply that by the number of open source projects you have and their popularity. End result: open source can be a bummer.&lt;/p&gt;

&lt;p&gt;Jacob Thornton (&lt;a href="https://twitter.com/fat"&gt;@fat&lt;/a&gt;), co-author of Bootstrap, gave a talk a few years back echoing the sentiment of many open source authors and maintainers. He calls it Cute Puppy Syndrome. It's not the best analogy, but it gets the point across. Open source projects, like puppies, are great fun when they start. As they get older and more mature, responsibility seems to outweigh their cuteness. One solution is to put your old dog up for adoption and get a new puppy. As you can tell from his delivery, this analogy is intended to be humorous:&lt;/p&gt;

&lt;p style="text-align:center;"&gt;&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/UIDb6VBO9os?start=1190" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;He mentions that many authors of popular open source projects have gotten burnt out and look for an exit. Often handing projects off to maintainers, sometimes never to return. Not to avoid responsibility, but to stay sane. Still, much of the time, that sense of responsibility lingers. As Jacob expands on the puppy analogy:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you have your puppy and it turns into a dog, you put it up for adoption, you give it to a maintainer. And then he over feeds it and it becomes fat and bloated. And you just sit there and you're really sad because you don't really have time to take care of your puppy any more, but you don't want to see it fat and bloated. So you're just real sad all the time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alternatively, you can let issues and PRs pile up. Guilt and sadness either way. At least opening the project up lets it survive and continue to provide value to a larger audience. You just have to let go of the project as it will now evolve in ways you might not agree with.&lt;/p&gt;

&lt;p&gt;When I did this with &lt;a href="http://progrium.viewdocs.io/dokku/"&gt;Dokku&lt;/a&gt;, the new maintainers did a great job at keeping the project and community healthy. I can't thank them enough for that. I had to let go quite a bit, but the project would probably be dead without them.&lt;/p&gt;

&lt;p&gt;In fact, there's something interesting about maintainers that didn't author the project. It's probably different from person to person and project to project, but the maintainers of Dokku don't have the guilt or burden that I do. They're happy to help, and as volunteers don't feel like they owe anybody anything. It's really the ideal situation. Perhaps authors &lt;em&gt;shouldn't&lt;/em&gt; be maintainers after a certain point.&lt;/p&gt;

&lt;p&gt;That said, even with these great maintainers, Dokku really only kept on an incremental path of maintaining the status quo. That's not necessarily a bad thing, but it meant Dokku wasn't able to develop further in the directions I had originally intended. I thought to myself, well eventually I'll find time to do a system-wide refactoring to get it on this path I want and submit these as PRs like any other contributor. That time never came, and the project continued to fall behind from the evolving larger vision. The project I started was not living up to my own expectations for it.&lt;/p&gt;

&lt;p&gt;Sadness. Guilt.&lt;/p&gt;

&lt;p&gt;Then I did something different. It was so simple. I wrote a wiki page describing what I wanted and why I wanted it. For some reason it came as a surprise to me that the maintainers started moving the project in that direction! Did it happen exactly how I'd do it? Not always. But it still brought the project closer to what I wrote down.&lt;/p&gt;

&lt;p&gt;This shouldn't have come as a surprise. In essence, this is leadership. There are different forms of leadership, but at the core is the idea of "saying what, not how". It can be very hard for programmers to get into this mindset because our medium is all about the how. Stepping back and writing what you want with flexibility towards how it's implemented takes practice.&lt;/p&gt;

&lt;p&gt;This experiment with Dokku was far from perfect. In fact, that document is still incomplete. Project leadership is just as ongoing as maintenance. However, it's something worth getting better at. It's essential to authoring many open source projects and remaining happy enough to keep going. In the case of my projects, since there is always a bigger picture they fit into, it's even more important.&lt;/p&gt;

&lt;p&gt;Dokku is just one of many projects, but Dokku is one of my only projects that I'm not an active maintainer. Dokku isn't why I had to take a break, it was all the others.&lt;/p&gt;

&lt;p&gt;Some of you might have seen my ramblings about &lt;a href="http://progrium.com/blog/2015/10/05/the-next-10-years-megalith/"&gt;Megalith&lt;/a&gt;. Some of you might even be able to follow them enough to see that most of my open source projects are all basically part of Megalith. Or that Megalith is basically all my projects. You can probably see how this leadership is critical to sustain all these projects while keeping them moving in roughly the same direction.&lt;/p&gt;

&lt;p&gt;I don't write open source software to make money. In fact, even solving a particular problem is secondary to working towards a vision of how the world should be. Since that's really what's important to me, I should be spending my time on being an effective leader. At the very least, documenting what I want, the direction, why it's important, what design principles are involved, preferred architectural patterns, and so on. Then helping people understand, integrating their feedback, and letting go of a lot of the details.&lt;/p&gt;

&lt;p&gt;To support this, I need to open up our projects to more maintainers. Going forward, I'll be trying a variation of the &lt;a href="http://felixge.de/2013/03/11/the-pull-request-hack.html"&gt;Pull Request Hack&lt;/a&gt; to get more people involved across all projects. If you submit a solid substantial PR or several solid minor PRs to any Glider Labs project, you'll be invited to have commit access across all projects.&lt;/p&gt;

&lt;p&gt;Starting now, all public projects under &lt;a href="https://github.com/progrium"&gt;my username&lt;/a&gt; or &lt;a href="https://github.com/gliderlabs"&gt;Glider Labs&lt;/a&gt; have an open call for maintainers. If you'd like to volunteer to help maintain any of these projects, just &lt;a href="http://glider-slackin.herokuapp.com/"&gt;join our Slack&lt;/a&gt; and in &lt;code&gt;#intros&lt;/code&gt; say you're interested in becoming a maintainer.&lt;/p&gt;

&lt;p&gt;From there I'll do my best to provide guidance and leadership. Together we'll keep making great things!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>The Next 10 Years: Megalith</title>
    <link rel="alternate" href="http://progrium.com/blog/2015/10/05/the-next-10-years-megalith/"/>
    <id>http://progrium.com/blog/2015/10/05/the-next-10-years-megalith/</id>
    <published>2015-10-05T23:47:00+00:00</published>
    <updated>2016-02-13T15:49:55+00:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;I've decided what I'm going to be working on for the next 10 years. It's epic and exciting, and I'm going to need your help. It's called Megalith.&lt;/p&gt;

&lt;p&gt;Megalith is a symbol of the ideal I've been working towards my entire career. It's constantly evolving and very nuanced. I'm going to be upfront and say that I'm not going to be able to fully explain what Megalith is in this post. Instead, I'm going to start setting up context. To me, context is everything.&lt;/p&gt;

&lt;p&gt;For the past few years I've been spending most of my working hours writing open source software related to a project I worked on in 2012 called &lt;a href="http://docker.com"&gt;Docker&lt;/a&gt;. Docker was created as a skunkworks collaboration between me and some talented engineers at dotCloud, now Docker. The company pivoted 100% to Docker and is now worth about a billion dollars. As an independent, I didn't stay with Docker, I moved on to the next problem. Docker was one piece of a grander vision.&lt;/p&gt;

&lt;p&gt;To help pay for this lifestyle, I've experimented with sponsorships and even fell into lucky situations. Last year I tried to make it a little more sustainable by starting &lt;a href="http://gliderlabs.com"&gt;Glider Labs&lt;/a&gt; with a friend. We focused on consulting around Docker. We helped some of the first people to actually run Docker in production. We did this to learn and get a better grasp on the Real Problems. Something many vendors in this space don't really do. We learned a lot and as a result we ended up making a lot more open source software.&lt;/p&gt;

&lt;p&gt;The problem is that there is a lot more to make. This ideal I have in mind that's been developing in my head for over 5 years is a massive undertaking. I've realized if I'm going to keep pursuing it, I need two things: a better vehicle for the work, and a unifying project to get help around it.&lt;/p&gt;

&lt;h2 id="building-a-better-organization-for-this-work"&gt;Building a better organization for this work&lt;/h2&gt;

&lt;p&gt;The software I write that people love comes from a compulsive drive that goes beyond and even against the idea of startups. With the exception of Docker and a few other collaborations, I've never made anything that people loved while working for a startup. Naming and evangelizing webhooks was not something anybody paid me to do. In fact, a lot of projects I've built or think should exist are too small to sustain a startup. Does that mean they shouldn't be built? Or that I should temporarily dedicate my life to maybe make one of them work as a startup?&lt;/p&gt;

&lt;p&gt;Even a lifestyle business is quite a commitment to make work. My friend &lt;a href="https://inconshreveable.com/"&gt;Alan Shreve&lt;/a&gt; made &lt;a href="https://ngrok.com/"&gt;Ngrok&lt;/a&gt;, inspired by my tool &lt;a href="https://github.com/progrium/localtunnel"&gt;Localtunnel&lt;/a&gt;. It's free and open source, but he's also bootstrapped a business out of it. This business is what he spends most his working hours on.&lt;/p&gt;

&lt;p&gt;Given my goals and values I do prefer this approach, but it still poses a problem. The time spent writing lines of code to support a business, the time spent figuring out market fit, the time spent on support and operations … this is time not moving forward to me. It's extracting wealth out of something that already exists.&lt;/p&gt;

&lt;p&gt;Why do this? So Alan can sustain himself and potentially fund other projects, right? In the meantime, I know for a fact that there's a lot of great open source software that he's not making.&lt;/p&gt;

&lt;p&gt;His goal is passive income. For a lot of us independents, that's the dream. It may or may not realize in full, but it's certainly time consuming either way. In that way, it's sort of just a smaller variation of the startup lottery.&lt;/p&gt;

&lt;p&gt;Meanwhile, in the same time, I've put out dozens of open source projects that solve problems or work towards dissolving larger problems in the long-term. I actually can't help it. It's compulsive like I said. The only way I see it stopping is if I leave the space altogether. I don't get paid to do 90% of these projects. They help bring me contract work, but seemingly only to take time away from supporting and building a community around those projects.&lt;/p&gt;

&lt;p&gt;The other problem, for me, is that running a business causes you to make software differently. You think about building software you can sell, or that supports what you can sell. More than doing one thing well, you think about the features people will pay for. More than making it simple, you think about obscure enterprise and legacy use cases. Conventional knowledge says you must do those in some way at some point because that's How It Works.&lt;/p&gt;

&lt;p&gt;The problem is worse for startups that take VC money. Even VCs that "get it" and let you focus on open source traction still expect you to eventually figure out how to monetize and make them millions. To varying degrees this often makes startups:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;focus on enterprise customers, not regular developers&lt;/li&gt;
  &lt;li&gt;ship software that solves short-term problems, or yesterday's problems&lt;/li&gt;
  &lt;li&gt;prioritize sexy demoware without production hardening&lt;/li&gt;
  &lt;li&gt;increase perceived value with more hires and more partnerships&lt;/li&gt;
  &lt;li&gt;de-prioritize any effort outside the product that makes money&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://hashicorp.com/"&gt;Hashicorp&lt;/a&gt; is one of the best examples of companies in this space that have done a good job at taking just enough VC and working against a lot of these forces. However, they still work within the framework. They still have a commitment to exit big someday. The implications of this are not insignificant.&lt;/p&gt;

&lt;p&gt;I'm much more likely to bootstrap a company like Alan than take VC money. Not only is it just more my style, but a VC startup just won't play to my strengths. Though, building a bootstrap business doesn't seem to produce the most value for my time either. Or make me very happy.&lt;/p&gt;

&lt;p&gt;I'd much rather find a new way. Not just because I want to play to my strengths, but because I know I'm not the only one this applies to. I also know that a different, better kind of open source software will result if done properly.&lt;/p&gt;

&lt;p&gt;What I want is something of an independent R&amp;amp;D lab. I want us to &lt;a href="http://gliderlabs.com/blog/2015/04/08/what-have-we-been-doing-for-40-years/"&gt;re-capture&lt;/a&gt; the innovation and &lt;em&gt;invention&lt;/em&gt; of Xerox PARC and Bell Labs, but focusing on open source. I want us to have the freedom to explore and build software &lt;em&gt;right&lt;/em&gt; with like-minded people. Not to get rich, but to &lt;em&gt;slow cook software&lt;/em&gt;. Systems software that further empowers individuals and small groups … enterprise customers of the future, not the past.&lt;/p&gt;

&lt;p&gt;This is what I want Glider Labs to transition into. In fact, it's already been operating like this in a way. And I've been exploring and learning ways to make this work for years now. It's part business, part cooperative, part public service. But to make the leap to a lab that supports more than myself, it won't happen over night. And I can't do it by myself.&lt;/p&gt;

&lt;h2 id="sharing-the-vision-enabling-participation"&gt;Sharing the vision, enabling participation&lt;/h2&gt;

&lt;p&gt;This isn't just about a new organization. It has to have some purpose, some initial unifying project. In order to start from nothing, there needs to be a clear mission of value. Not just boundless experimentation. Luckily, most of my work does fall under a certain theme driven by a nebulous but nonetheless motivating ideal. That seems like a good place to start.&lt;/p&gt;

&lt;p&gt;I've been told if I just wrote down everything I want to build and why, people might be willing to help out. This is challenging both because of scope and its constant evolution. I figured if I just keep making projects people will start to see it, but other than a few people I'm not sure that's working out. So I'm going to try a more top-down approach.&lt;/p&gt;

&lt;p&gt;The real project this post is about is a meta-project I'm calling Megalith. It's an umbrella project to help unify and bring a common goal to all the work I've been doing for the past 10 years, and over the next 10 years.&lt;/p&gt;

&lt;p&gt;I know I can't do it alone, so the project is designed for participation. It will involve many more specific projects that are open source and independently useful. Many already exist. Most do not.&lt;/p&gt;

&lt;p&gt;Whether or not the final ideal is achieved, it will be approached. Lots of value will be produced in the process. Not just software and contributions to existing open source, but guides and how-to knowledge of everything I've learned to lead me to my current conclusions, and everything we learn in the process.&lt;/p&gt;

&lt;p&gt;Glider Labs and Megalith are separate but related parts of this venture. Megalith is the meta-project, Glider Labs is the organization. The idea is that they support each other. Megalith makes this new Glider Labs a reality, Glider Labs makes Megalith a reality.&lt;/p&gt;

&lt;h2 id="relevant-to-your-interests"&gt;Relevant to your interests?&lt;/h2&gt;

&lt;p&gt;The first step is to explain Megalith and try to communicate this idea in my head, or at least some manifestation of it. Then everything else will start to make sense. It's almost more about approach and values. It's about an idea of simple, composable, extensible tools to make modern end-to-end development and operations sane at both large and small scale. And making the world more programmable…&lt;/p&gt;

&lt;p&gt;Anyway, it's more than I can get into here. I've set up &lt;a href="http://eepurl.com/bAietL"&gt;an announcement mailing list&lt;/a&gt; you can subscribe to. Sign up and you'll get emails about what's next. I might even email you directly to say hi.&lt;/p&gt;

&lt;p&gt;Feel free to get in touch with me, leave a comment below, or help out by sharing this post if it resonates with you. I'm pretty excited, especially since a lot of people have expressed interest so far.&lt;/p&gt;

&lt;p&gt;Lastly, here's a silly video I made about it:&lt;/p&gt;

&lt;center&gt;&lt;iframe src="https://player.vimeo.com/video/140272143" width="600" height="337" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href="http://eepurl.com/bAietL"&gt;Subscribe for updates!&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Deis Breathes New Life into Dokku</title>
    <link rel="alternate" href="http://progrium.com/blog/2014/10/28/deis-breathes-new-life-into-dokku/"/>
    <id>http://progrium.com/blog/2014/10/28/deis-breathes-new-life-into-dokku/</id>
    <published>2014-10-28T01:35:00+00:00</published>
    <updated>2016-02-13T15:49:55+00:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;Today I'm excited to announce that &lt;a href="https://github.com/progrium/dokku"&gt;Dokku&lt;/a&gt; is now sponsored by my friends of the &lt;a href="http://deis.io/"&gt;Deis&lt;/a&gt; project. This means that &lt;a href="http://opdemand.com/"&gt;OpDemand&lt;/a&gt;, the company behind Deis, will be funding part-time development of Dokku and its components.&lt;/p&gt;

&lt;h2 id="remember-dokku"&gt;Remember Dokku?&lt;/h2&gt;

&lt;p&gt;A little over a year ago, &lt;a href="http://progrium.com/blog/2013/06/19/dokku-the-smallest-paas-implementation-youve-ever-seen/"&gt;I announced Dokku&lt;/a&gt; as an open source "Docker powered mini-Heroku." It quickly became the first killer application for Docker. Designed to be simple and hackable, Dokku enables web developers to run their own single-host PaaS that's directly compatible with Heroku.&lt;/p&gt;

&lt;p&gt;As the project took off, I went on to tackle the challenges of a multi-host PaaS with the &lt;a href="https://flynn.io/"&gt;Flynn&lt;/a&gt; team. Even without me, the Dokku community continued to grow, thanks to the help of new maintainers and contributors. The experimental plugin system allowed all sorts of customizations and extensions of Dokku to flourish.&lt;/p&gt;

&lt;p&gt;Over time, though, the wonderful volunteer maintainers of the project started to get burnt out. Handling issues across a dozen language runtimes and even more plugins is taxing. Many were upstream buildpack or Docker issues, or larger inherent problems of the project requiring stronger leadership to resolve.&lt;/p&gt;

&lt;p&gt;Although Dokku is still used and loved today, without active maintainership and leadership, it was at risk of "bit rot". I came to the conclusion that it was in need of some love from the original author. Luckily, the Deis team was willing to help make this happen and is effectively saving the project from a slow death.&lt;/p&gt;

&lt;h2 id="about-deis"&gt;About Deis&lt;/h2&gt;

&lt;p&gt;Not long after I started collaborating with the Flynn team, another project called Deis came onto the scene. Both projects have the goal of being enterprise grade, multi-host PaaS solutions. Although technically competitive, as open source projects composed of great people, we openly share information and components. As an independent agent, I try to bridge silos and facilitate that kind of sharing and communication. I'd gone out to visit both teams to collaborate, talk shop, and have fun.&lt;/p&gt;

&lt;p&gt;I eventually moved on from Flynn and started independently exploring distributed systems components in a Docker world. Deis continued to adopt and support many of my open source components. They always kept an open dialog with me and others in the Docker community. When I mentioned my plans to reinvigorate Dokku, they were quick to offer help.&lt;/p&gt;

&lt;h2 id="the-sponsorship"&gt;The Sponsorship&lt;/h2&gt;

&lt;p&gt;The timing for this sponsorship is perfect. Deis now requires at least 3 hosts in a cluster, making Dokku the obvious recommendation for smaller deployments. The projects will focus on shared components even more. This sponsorship will also ensure a smooth migration to Deis if a Dokku user wants to go down that path.&lt;/p&gt;

&lt;p&gt;What is Dokku expected to get? First, time and thought put into getting the project modernized and on path for a solid 1.0 release. Among other things, this involves redesigning aspects of the project to make it more sustainable as an open source project.&lt;/p&gt;

&lt;p&gt;Much of the lessons of Flynn and Deis, as well as reflections on Dokku itself, will feed back into Dokku. My plan is to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;make it more robust and testable&lt;/li&gt;
  &lt;li&gt;improve code quality and standards&lt;/li&gt;
  &lt;li&gt;properly direct upstream issues upstream&lt;/li&gt;
  &lt;li&gt;improve documentation and basic support processes&lt;/li&gt;
  &lt;li&gt;add popular features, such as addons and Dockerfile build support&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And if you can believe it, I plan to make it more modular and even simpler.&lt;/p&gt;

&lt;h2 id="yay-dokku"&gt;Yay, Dokku!&lt;/h2&gt;

&lt;p&gt;Along with Deis, I want to thank all the &lt;a href="https://github.com/progrium/dokku/graphs/contributors"&gt;contributors&lt;/a&gt; and maintainers involved in Dokku. I especially want to thank asm89, rhy-jot, plieter, fcoury, and josegonzalez. The project would already be dead without them. If you want to get involved, I'll generally be in the &lt;code&gt;#dokku&lt;/code&gt; channel on Freenode sharing updates as I progress. Most of my work will be in a new branch, but first it will take place in creating and updating components used by Dokku.&lt;/p&gt;

&lt;p&gt;I'm only able to put a day or so of hours a week into the project, but steady, consistent effort and help from the community will ensure Dokku will be around for a long time!&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>Automatic Docker Service Announcement with Registrator</title>
    <link rel="alternate" href="http://progrium.com/blog/2014/09/10/automatic-docker-service-announcement-with-registrator/"/>
    <id>http://progrium.com/blog/2014/09/10/automatic-docker-service-announcement-with-registrator/</id>
    <published>2014-09-10T22:19:00+00:00</published>
    <updated>2016-02-13T15:49:55+00:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;No matter which service discovery system you use, it will not likely know how to register your services for you. Service discovery requires your services to somehow announce themselves to the service directory. This is not as trivial as it sounds. There are many approaches to do this, each with their own pros and cons.&lt;/p&gt;

&lt;p&gt;In an ideal world, you wouldn't have to do anything special. With Docker, we can actually arrange this with a component I've made called &lt;a href="https://github.com/progrium/registrator"&gt;Registrator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before I get to Registrator, let's understand what it means to register a service and see what kind of approaches are out there for registering or announcing services. It might also be a good idea to see my last posts &lt;a href="http://progrium.com/blog/2014/08/20/consul-service-discovery-with-docker/"&gt;on Consul&lt;/a&gt; and &lt;a href="http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/"&gt;on service discovery&lt;/a&gt; in general.&lt;/p&gt;

&lt;h2 id="service-registration-data-model"&gt;Service Registration Data Model&lt;/h2&gt;

&lt;p&gt;Service registration involves a few different pieces of information that describes a service. At the very least, it will involve a service name, such as "web", and a locating IP and port. Often, there is a unique ID for a service instance ("web.2"). Some systems generate this automatically.&lt;/p&gt;

&lt;p&gt;Around this, there might be extra information or metadata associated with a service. In some systems this could be key-value attributes. Or maybe just tags. Classic service discovery of the zero-configuration world would also include the protocol (HTTP, SMTP, Jabber, etc), but this isn't very useful information since in our case we already know the protocol of the service we're looking for.&lt;/p&gt;

&lt;p&gt;When using etcd or Zookeeper it's up to you how your service directory works, both what information is stored and how to structure it. Specialized service discovery systems like Flynn's discoverd or Netflix's Eureka provide more structure around service semantics. Consul is sort of a hybrid, since it's really a specialized service discovery system built-in to a general configuration store.&lt;/p&gt;

&lt;p&gt;Consul lets you define a service name, IP, port, optional service ID, and optional tags. In a future release, I believe it will tie in more with the key-value store to allow you to have arbitrary attributes associated with a service. Right now, Consul also lets you define a health check to use with its monitoring system, which is unique to Consul.&lt;/p&gt;

&lt;p&gt;So far, that gives you an idea of the data involved in registering a single service, but that's not the complete model. A service "record" is a reference to an actual service, and it's important to understand what that actually is. Whether using containers or not, a service will always boil down to a long-running process, and a process may listen on several ports. This could imply multiple services.&lt;/p&gt;

&lt;p&gt;One could argue that if a process listens on multiple ports for the same functional service, it might be a good idea to collapse it into a single service. Modeling it in this way ends up being either complicated (putting the other service ports in meta-data), or incomplete ("which port do I use for TLS?"). I've found it's simplest to just model each port a process listens on as a separate service, using the name to logically group them. For example, "webapp-http" and "webapp-https".&lt;/p&gt;

&lt;h2 id="registering-in-process-or-using-a-coprocess"&gt;Registering In-process or Using a Coprocess&lt;/h2&gt;

&lt;p&gt;The most common strategy to register in service discovery is actually directly self-registering from the service process itself. From a "good solution" perspective, this might seem terrible. But it's common for a reason. Mostly, it's pragmatic, as many organizations build their specific services around their specific service discovery system. However, it does have other advantages.&lt;/p&gt;

&lt;p&gt;Service discovery systems like Eureka and discoverd provide a library that can be used in your service to register itself, as well as lookup and discover other services from in-process. This provides opportunities like having balancing and connection pooling logic taken care of for you, without the extra hop of a reverse proxy. And in cases where heartbeats are used for liveness, the library can handle heartbeating for you.&lt;/p&gt;

&lt;p&gt;The disadvantage of this approach as a reusable system is that libraries are hard provide across languages, so there might be limited language support for the library. Depending on how complex the library is, it may also be difficult to port for people that want to make the effort to expand language support.&lt;/p&gt;

&lt;p&gt;Though, the biggest disadvantage is putting the responsibility on the service in the first place. This creates two problems. First, if you intend to make your services useful to anybody else, your service will be less portable across environments that use different discovery mechanisms. Netflix open source projects suffer from this, as people already complain it's too hard to use some of their components without using all of them. Second, third-party components and services like Nginx, Memcached, or pretty much any datastore will not register themselves.&lt;/p&gt;

&lt;p&gt;While some software might provide hooks or extensions to integrate with your service discovery, this is pretty rare. And patching is not a scalable solution. Instead, the common solution for third-party services is to put the registering responsibility &lt;em&gt;near&lt;/em&gt; the service.&lt;/p&gt;

&lt;p&gt;If you're not directly registering in-process, the second most common approach is running another parallel process to register the service. This works best with a process manager like systemd that can ensure if the service starts, so does the paired registering service.&lt;/p&gt;

&lt;p&gt;Some call this technique using a coprocess or a "sidekick". When working with containers, I usually use coprocess in reference to another process in the same container. A sidekick would be a separate container and process. Either way, this is a useful pattern even beyond service registration. I use it for other administrative services that support the main service, for example to re-configure the service. The open source PaaS Deis used this pattern for shipping out a service's logs. However, it seems to simplify they're &lt;a href="https://github.com/deis/deis/issues/1714"&gt;moving to my tool logspout&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A variation of using a coprocess is process "wrapping", where you use a launcher process that will register and run the service as a child process. Flynn does this with sdutil. Some might say it can make starting services feel very complicated since you now have to configure the service as usual, on top of providing registration details to the launcher. At the end of the day, this is effectively the coprocess model launched with one command instead of two.&lt;/p&gt;

&lt;h2 id="the-problem-with-a-coprocess-for-registering"&gt;The Problem with a Coprocess for Registering&lt;/h2&gt;

&lt;p&gt;In whatever form it comes, a coprocess comes with two challenges: configuration and manageability.&lt;/p&gt;

&lt;p&gt;With a parallel announcing process, you need to tell it what service or services it should announce, providing it all the information we talked about before. An interesting problem with any external registration solution is where that service description is stored. For example, if you were doing announcement in-process, it would at least already know what ports it exposes. However, it most likely wouldn't know what the operator wants to call it. Some systems will roll all this information up into higher-level system constructs, like "service groups" or some unit of orchestration. I prefer not to couple service discovery with orchestration. Instead, I'd rather service semantics live as close to the service process as possible.&lt;/p&gt;

&lt;p&gt;A coprocess or sidekick for registering also means you'll have one for every service you start. There is no technical problem with this, but it introduces operational complexity. A system has to manage this, whether it's a process manager like systemd or full-on orchestration. That system likely has to be configured, adding more configuration, which may or may not be the right place to define the service. And now you need to be sure to always use this system to launch any service, since running a service by hand will not register the service.&lt;/p&gt;

&lt;p&gt;In an ideal world, we don't worry about any of this. We just run a service and its ports somehow get registered as services. If we want to specify more details about the service, we can do this in a way that's packaged as close to the service as possible. And of course, we want an operator and automation friendly way to set or override that service definition at runtime.&lt;/p&gt;

&lt;h2 id="how-docker-helps-achieve-the-ideal"&gt;How Docker Helps Achieve the Ideal&lt;/h2&gt;

&lt;p&gt;Running services in Docker provides a number of benefits, and those who believe Docker is just about container isolation clearly miss the point. Docker defines a standard unit of software that can have anything in it and yet have a standard interface of operations. This interface works with a runtime that gives you certain capabilities in managing and operating that unit of software. These capabilities and this common container model happen to have everything we need to automatically register services for any software.&lt;/p&gt;

&lt;p&gt;The Docker container image includes default environment variables, which can be defined by the Dockerfile. This turns out to be the perfect place to describe the service it contains. The container author has the option to use the environment variables to include their idea of how the service should be described and registered, which will be shipped with the container wherever it goes. The operator can then set runtime environment variables to further define or redefine their own description of the service.&lt;/p&gt;

&lt;p&gt;The Docker runtime makes these values easy to inspect programmatically. The runtime also produces events when a container starts or stops, which is generally when you want to register or deregister the services of the container.&lt;/p&gt;

&lt;p&gt;All this together lets us provide automatic service registration for any Docker container using a little appliance I've made called Registrator.&lt;/p&gt;

&lt;h2 id="introducing-registrator"&gt;Introducing Registrator&lt;/h2&gt;

&lt;p&gt;Registrator is a single, host-level service you run as a Docker container. It watches for new containers, inspects them for service information, and registers them with a service registry. It also deregisters them when the container dies. It has a pluggable registry system, meaning it can work with a number of service discovery systems. Currently it supports Consul and etcd.&lt;/p&gt;

&lt;p&gt;There are a few neat properties of Registrator:&lt;/p&gt;

&lt;p&gt;First, it's automatic. You don't have to do anything special other than have Registrator running and attached to a service registry. Any public port published is registered as a service.&lt;/p&gt;

&lt;p&gt;Related but fairly significant, it requires no cooperation from inside the container to register services. If no service description is included and the operator doesn't specify any at runtime, it uses Docker container introspection for good defaults.&lt;/p&gt;

&lt;p&gt;Next, it uses environment variables as generic metadata to define the services. Some people have asked how you can add metadata to Docker containers, but the answer is right in front of them. As mentioned this comes with the benefit of being able to define them during container authorship, as well as at runtime.&lt;/p&gt;

&lt;p&gt;Lastly, the metadata Registrator uses could become a common interface for automatic service registration beyond Registrator and even beyond Docker. Environment variables are a portable metadata system and Registrator defines a very data-driven way to define services. That same data could be used by any other system.&lt;/p&gt;

&lt;p&gt;In terms of previous work, Michael Crosby's project &lt;a href="https://github.com/crosbymichael/skydock"&gt;Skydock&lt;/a&gt; was a big inspiration on the direction of Registrator, so it might be worth looking into for reference. Registrator is a little more generic and made specifically for distributed systems, not as much for single host registries. For example, Registrator focuses on published ports and uses a host-level IP as opposed to local container IPs. For people interested in single-host discovery, Registrator has already inspired compatible alternatives, including Brian Lalor's &lt;a href="https://github.com/blalor/docker-hosts"&gt;docker-hosts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In any case, I believe I've made the first general purpose solution to automatic service registration. Here's a video demo:&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;iframe src="//player.vimeo.com/video/105806672" width="640" height="360" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id="onward"&gt;Onward…&lt;/h2&gt;

&lt;p&gt;In retrospect, the problem we've solved here now seems very trivial, but we've never had this before. Like many good designs, it can take a while for all the pieces to come together and make sense in one's mind before it becomes obvious. Once it's obvious, it seems like it always was.&lt;/p&gt;

&lt;p&gt;Combining auto-registration with a good service directory, you're almost to an ideal service discovery system. That last problem is about the other side of discovery: connecting to registered services. The next post will describe how this is also not as trivial as it sounds, and as usual, I will offer an open source solution.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Consul Service Discovery with Docker</title>
    <link rel="alternate" href="http://progrium.com/blog/2014/08/20/consul-service-discovery-with-docker/"/>
    <id>http://progrium.com/blog/2014/08/20/consul-service-discovery-with-docker/</id>
    <published>2014-08-20T20:05:00+00:00</published>
    <updated>2016-02-13T15:49:55+00:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://www.consul.io/"&gt;Consul&lt;/a&gt; is a powerful tool for building distributed systems. There are a handful of alternatives in this space, but Consul is the only one that really tries to provide a comprehensive solution for service discovery. As my &lt;a href="/blog/2014/07/29/understanding-modern-service-discovery-with-docker/"&gt;last post&lt;/a&gt; points out, service discovery is a little more than what Consul can provide us, but it is probably the biggest piece of the puzzle.&lt;/p&gt;

&lt;h2 id="understanding-consul-and-the-config-store"&gt;Understanding Consul and the "Config Store"&lt;/h2&gt;

&lt;p&gt;The heart of Consul is a particular class of distributed datastore with properties that make it ideal for cluster configuration and coordination. Some call them lock servers, but I call them "config stores" since it more accurately reflects their key-value abstraction and common use for shared configuration.&lt;/p&gt;

&lt;p&gt;The father of config stores is Google's Chubby, which was never made publicly available but is described in the influential &lt;a href="http://research.google.com/archive/chubby.html"&gt;Chubby paper&lt;/a&gt;. In the open source world we have Apache Zookeeper, the mostly defunct doozerd, and in the last year, etcd and Consul.&lt;/p&gt;

&lt;p&gt;These specialized datastores are defined by their use of a consensus algorithm requiring a quorum for writes and generally exposing a simple key-value store. This key-value store is highly available, fault-tolerant, and maintains strong consistency guarantees. This can be contrasted with a number of alternative clustering approaches like master-slave or two-phase commit, all with their own benefits, drawbacks, and nuances.&lt;/p&gt;

&lt;p&gt;You can learn more about the challenges of designing stateful distributed systems with the online book, &lt;a href="http://book.mixu.net/distsys/single-page.html"&gt;Distributed systems for fun and profit&lt;/a&gt;. This image from the book summarizes where the quorum approach stands compared to others:&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;img src="/images/content/embassy/google-transact09.png" title="Diagram borrowed with love from Distributed systems for fun and profit" /&gt;&lt;/p&gt;

&lt;p&gt;Quorum datastores such as our config stores seem to have many ideal properties &lt;em&gt;except&lt;/em&gt; for performance. As a result, they're generally used as low-throughput coordinators for the rest of the system. You don't use them as your application database, but you might use them to coordinate replacing a failed database master.&lt;/p&gt;

&lt;p&gt;Another common property of config stores is they all have mechanisms to watch for key-value changes in real-time. This feature is central in enabling use-cases such as electing masters, resource locking, and service presence.&lt;/p&gt;

&lt;h2 id="along-comes-consul"&gt;Along comes Consul&lt;/h2&gt;

&lt;p&gt;Since Zookeeper came out, the subsequent config stores have been trying to simplify. Both in terms of user interface, ease of operation, and implementation of the consensus algorithms. However, they're all based on this very expressive, but lowest common denominator abstraction of a key-value store.&lt;/p&gt;

&lt;p&gt;Consul is the first to build on top of this abstraction by also providing specific APIs around the semantics of common config store functions, namely service discovery and locking. It also does it in a way that's very thoughtful about those particular domains.&lt;/p&gt;

&lt;p&gt;For example, a directory of services without service health is actually not a very useful one. This is why Consul also provides monitoring capabilities. Consul monitoring is comparable, and even compatible, with Nagios health checks. What's more, Consul's agent model makes it more scalable than centralized monitoring systems like Nagios.&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;img src="/images/content/embassy/consul_layers.png" /&gt;&lt;/p&gt;

&lt;p&gt;A good way to think of Consul is broken into 3 layers. The middle layer is the actual config store, which is not that different from etcd or Zookeeper. The layers above and below are pretty unique to Consul.&lt;/p&gt;

&lt;p&gt;Before Consul, HashiCorp developed a host node coordinator called Serf. It uses an efficient gossip protocol to connect a set of hosts into a cluster. The cluster is aware of its members and shares an event bus. This is primarily used to know when hosts come and go from the cluster, such as during a host failure. But in Serf the event bus was also exposed for custom events to trigger user actions on the hosts.&lt;/p&gt;

&lt;p&gt;Consul leverages Serf as a foundational layer to help maintain its cluster. For the most part, it's more of an implementation detail. However, I believe in an upcoming version of Consul, the Serf event bus will also be exposed in the Consul API.&lt;/p&gt;

&lt;p&gt;The key-value store in Consul is very similar to etcd. It shares the same semantics and basic HTTP API, but differs in subtle ways. For example, the API for reading values lets you optionally pick a consistency mode. This is great not just because it gives users a choice, but it documents the realities of different consistency levels. This transparency educates the user about the nuances of Consul's replication model.&lt;/p&gt;

&lt;p&gt;On top of the key-value store are some other great features and APIs, including locks and leader election, which are pretty standard for what people originally called lock servers. Consul is also datacenter aware, so if you're running multiple clusters, it will let you federate clusters. Nothing complicated, but it's great to have built-in since spanning multiple datacenters is very common today.&lt;/p&gt;

&lt;p&gt;However, the killer feature of Consul is its service catalog. Instead of using the key-value store to arbitrarily model your service directory as you would with etcd or Zookeeper, Consul exposes a specific API for managing services. Explicitly modeling services allows it to provide more value in two main ways: monitoring and DNS.&lt;/p&gt;

&lt;h2 id="built-in-monitoring-system"&gt;Built-in Monitoring System&lt;/h2&gt;

&lt;p&gt;Monitoring is normally discussed independent of service discovery, but it turns out to be highly related. Over the years, we've gotten better at understanding the importance of monitoring service health in relation to service discovery.&lt;/p&gt;

&lt;p&gt;With Zookeeper, a common pattern for service presence, or liveness, was to have the service register an "ephemeral node" value announcing its address. As an ephemeral node, the value would exist as long as the service's TCP session with Zookeeper remained active. This seemed like a rather elegant solution to service presence. If the service died, the connection would be lost and the service listing would be dropped.&lt;/p&gt;

&lt;p&gt;In the development of doozerd, the authors avoided this functionality, both for the sake of simplicity and that they believed it encouraged bad practice. The problem with relying on a TCP connection for service health is that it doesn't exactly mean the service is healthy. For example, if the TCP connection was going through a transparent proxy that accidentally kept the connection alive, the service could die and the ephemeral node may continue to exist.&lt;/p&gt;

&lt;p&gt;Instead, they implemented values with an optional TTL. This allowed for the pattern of actively updating the value if the service was healthy. TTL semantics are also used in etcd, allowing the same active heartbeat pattern. Consul supports TTL as well, but primarily focuses on more robust liveness mechanisms. In the discovery layer I helped design for Flynn, our client library lets you register your service and it will automatically heartbeat for you behind the scenes.&lt;/p&gt;

&lt;p&gt;This is generally effective for service presence, but it might not take the lesson to heart. Blake Mizerany, the co-author of doozerd and now maintainer of etcd, will stress the importance of &lt;em&gt;meaningful&lt;/em&gt; liveness checks. In other words, there is no one-size-fits-all. Every service performs a different function and without testing that specific functionality, we don't actually know that it's working properly. Generic heartbeats can let us know if the process is running, but not that it's behaving correctly enough to safely accept connections.&lt;/p&gt;

&lt;p&gt;Specialized health checks are exactly what monitoring systems give us, and Consul gives us a distributed monitoring system. Then it lets us choose if we want to want to associate a check with a service, while also supporting the simpler TTL heartbeat model as an alternative. Either way, if a service is detected as not healthy, it's hidden from queries for active services.&lt;/p&gt;

&lt;h2 id="built-in-dns-server"&gt;Built-in DNS Server&lt;/h2&gt;

&lt;p&gt;In my last post, I mentioned how DNS is not a sufficient technology for service discovery. I was very hesitant in accepting the value of a DNS interface to services in Consul. As I described before, all our environments are set up to use DNS for resolving names to IPs, not IPs with ports. So other than identifying the IPs of hosts in the cluster, the DNS interface at first glance seems to provide limited value, if any, for our concept of service discovery.&lt;/p&gt;

&lt;p&gt;However, it does serve SRV records for services, and this is huge. Built-in DNS resolvers in our environments don't lookup SRV records, however, the library support to do SRV lookups ourselves is about as ubiquitous as HTTP. This took me a while to realize. It means we all have a client, even more lightweight than HTTP, and it's made &lt;em&gt;specifically&lt;/em&gt; for looking up a service.&lt;/p&gt;

&lt;p&gt;To me this makes SRV the best standard API for simple service discovery lookups. I hope more service discovery systems implement it.&lt;/p&gt;

&lt;p&gt;In a later post in this series, we build on SRV records from Consul DNS to generically solve service inter-connections in Docker clusters. I don't think I would have realized any of this if Consul didn't provide a built-in DNS server.&lt;/p&gt;

&lt;h2 id="consul-and-the-ecosystem"&gt;Consul and the Ecosystem&lt;/h2&gt;

&lt;p&gt;Consul development is very active. In the past few months, they've had several significant releases, although it's still pre-1.0. Etcd is also actively being developed, though currently from the inside out, focusing on a re-design of their Raft implementation. The two projects are similar in many ways, but also very different. I hope they learn and influence each other, perhaps even share some code since they're both written in Go. At this point, though, Consul is ahead as a comprehensive service discovery primitive.&lt;/p&gt;

&lt;p&gt;Unfortunately, Consul is much less popular in the Docker world. Perhaps this is just due to less of a focus on containers at HashiCorp, which is contrasted by the heavily container-oriented mindset of the etcd maintainers at CoreOS.&lt;/p&gt;

&lt;p&gt;I've been trying hard to help bridge the Docker and Consul world by building a solid Consul container for Docker. I try to design containers to be self-contained, runtime-configurable appliances as much as possible. It was not hard to do this with Consul, which is now available on &lt;a href="https://github.com/progrium/docker-consul"&gt;Github&lt;/a&gt; or &lt;a href="https://registry.hub.docker.com/u/progrium/consul/"&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="running-consul-in-docker"&gt;Running Consul in Docker&lt;/h2&gt;

&lt;p&gt;Running a Consul node in Docker for a production cluster can be a bit tricky. This is due to the amount of configuration that the container itself needs for Consul to work. For example, here's how you might start one node using Docker (one command over several lines for readability):&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;$ docker run --name consul -h $HOSTNAME  \
    -p 10.0.1.1:8300:8300 \
    -p 10.0.1.1:8301:8301 \
    -p 10.0.1.1:8301:8301/udp \
    -p 10.0.1.1:8302:8302 \
    -p 10.0.1.1:8302:8302/udp \
    -p 10.0.1.1:8400:8400 \
    -p 10.0.1.1:8500:8500 \
    -p 172.17.42.1:53:53/udp \
    -d -v /mnt:/data \
    progrium/consul -server -advertise 10.0.1.1 -join 10.0.1.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Consul container I built comes with a helper command letting you simply run:&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;$ $(docker run progrium/consul cmd:run 10.0.1.1::10.0.1.2 -d -v /mnt:/data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just a special command to generate a full Docker run command like the first one, hence wrapping it in a subshell. It's not required, but a helpful convenience to hopefully get people started with Consul in Docker much quicker.&lt;/p&gt;

&lt;p&gt;One of the neat ways Consul and Docker can work together is by giving Consul as a DNS server to Docker. This transparently runs DNS resolution in containers through Consul. If you set this up at the Docker daemon level, you can also specify DNS search domains. That means the &lt;code&gt;.services.consul&lt;/code&gt; can be dropped, allowing containers to resolve records with just the service name.&lt;/p&gt;

&lt;p&gt;The project README has some pretty helpful getting started instructions as well as more detail on all these features. Here's a quick video showing how easy it is to get a Consul cluster up and running inside Docker, including the above DNS trick.&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;iframe src="//player.vimeo.com/video/103943481" width="640" height="360" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id="onward"&gt;Onward…&lt;/h2&gt;

&lt;p&gt;Once you have Consul running in Docker, you're &lt;em&gt;close&lt;/em&gt; to having great service discovery, but as I mentioned in my last post, you're still missing those second two legs. Stay tuned for the next post on automatically registering containerized services with Consul.&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>Understanding Modern Service Discovery with Docker</title>
    <link rel="alternate" href="http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/"/>
    <id>http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/</id>
    <published>2014-07-29T23:03:00+00:00</published>
    <updated>2016-02-13T15:49:55+00:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;Over the next few posts, I'm going to be exploring the concepts of service discovery in modern service-oriented architectures, specifically around Docker. Many people aren't familiar with service discovery, so I have to start from the beginning. In this post I'm going to be explaining the problem and providing some historical context around solutions so far in this domain.&lt;/p&gt;

&lt;p&gt;Ultimately, we're trying to get Docker containers to easily communicate across hosts. This is seen by some as one of the next big challenges in the Docker ecosystem. Some are waiting for &lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking"&gt;software-defined networking&lt;/a&gt; (SDN) to come and save the day. I'm also excited by SDN, but I believe that well executed service discovery is the right answer today, and will continue to be useful in a world with cheap and easy software networking.&lt;/p&gt;

&lt;h2 id="what-is-service-discovery"&gt;What is service discovery?&lt;/h2&gt;

&lt;p&gt;Service discovery tools manage how processes and services in a cluster can find and talk to one another. It involves a directory of services, registering services in that directory, and then being able to lookup and connect to services in that directory.&lt;/p&gt;

&lt;p&gt;At its core, service discovery is about knowing when any process in the cluster is listening on a TCP or UDP port, and being able to look up and connect to that port by name.&lt;/p&gt;

&lt;p&gt;Service discovery is a general idea, not specific to Docker, but is increasingly gaining mindshare in mainstream system architecture. Traditionally associated with &lt;a href="https://en.wikipedia.org/wiki/Zero-configuration_networking"&gt;zero-configuration networking&lt;/a&gt;, its more modern use can be summarized as facilitating connections to dynamic, sometimes ephemeral services.&lt;/p&gt;

&lt;p&gt;This is particularly relevant today not just because of service-oriented architecture and microservices, but our increasingly dynamic compute environments to support these architectures. Already dynamic VM-based platforms like EC2 are slowly giving way to even more dynamic higher-level compute frameworks like Mesos. Docker is only contributing to this trend.&lt;/p&gt;

&lt;h2 id="name-resolution-and-dns"&gt;Name Resolution and DNS&lt;/h2&gt;

&lt;p&gt;You might think, "Looking up by name? Sounds like DNS." Yes, name resolution is a big part of service discovery, but DNS alone is insufficient for a number of reasons.&lt;/p&gt;

&lt;p&gt;A key reason is that DNS was originally not optimized for closed systems with real-time changes in name resolution. You can get away with setting TTL's to 0 in a closed environment, but this also means you need to serve and manage your own internal DNS. What highly available DNS datastore will you use? What creates and destroys DNS records for your services? Are you prepared for the archaic world of DNS RFCs and server implementations?&lt;/p&gt;

&lt;p&gt;Actually, one of the biggest drawbacks of DNS for service discovery is that DNS was designed for a world in which we used standard ports for our services. HTTP is on port 80, SSH is on port 22, and so on. In that world, all you need is the IP of the host for the service, which is what an A record gives you. Today, even with private NATs and in some cases with IPv6, our services will listen on completely non-standard, sometimes random ports. Especially with Docker, we have many applications running on the same host.&lt;/p&gt;

&lt;p&gt;You may be familiar with SRV records, or "service" records, which were designed to address this problem by providing the port as well as the IP in query responses. At least in terms of a data model, this brings DNS closer to addressing modern service discovery.&lt;/p&gt;

&lt;p&gt;Unfortunately, SRV records alone are basically dead on arrival. Have you ever used a library or API to create a socket connection that didn't ask for the port? Where do you tell it to do an SRV record lookup? You don't. You can't. It's too late. Either software explicitly supports SRV records, or DNS is effectively just a tool for resolving names to host IPs.&lt;/p&gt;

&lt;p&gt;Despite all this, DNS is still a marvel of engineering, and even SRV records will be useful to us yet. But for all these reasons, on top of the demands of building distributed systems, most large tech companies went down a different path.&lt;/p&gt;

&lt;h2 id="rise-of-the-lock-service"&gt;Rise of the Lock Service&lt;/h2&gt;

&lt;p&gt;In 2006, Google released &lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/chubby-osdi06.pdf"&gt;a paper describing Chubby&lt;/a&gt;, their distributed lock service. It implemented distributed consensus based on Paxos to provide a consistent, partition-tolerant (CP in CAP theorem) key-value store that could be used for coordinating leader elections, resource locking, and reliable low-volume storage. They began to use this for internal name resolution instead of DNS.&lt;/p&gt;

&lt;p&gt;Eventually, the paper inspired an open source equivalent of Chubby called &lt;a href="http://zookeeper.apache.org"&gt;Zookeeper&lt;/a&gt; that spun out of the Hadoop Apache project. This became the de facto standard lock server in the open source world, mainly because there were no alternatives with the same properties of high availability and reliability over performance. The Paxos consensus algorithm was also non-trivial to implement.&lt;/p&gt;

&lt;p&gt;Zookeeper provides similar semantics as Chubby for coordinating distributed systems, and being a consistent and highly available key-value store makes it an ideal cluster configuration store and directory of services. It's become a dependency to many major projects that require distributed coordination, including Hadoop, Storm, Mesos, Kafka, and others. Not surprisingly, it's used in mostly other Apache projects, often deployed in larger tech companies. It is quite heavyweight and not terribly accessible to "everyday" developers.&lt;/p&gt;

&lt;p&gt;About a year ago, a simpler alternative to the Paxos algorithm was published called &lt;a href="http://raftconsensus.github.io/"&gt;Raft&lt;/a&gt;. This set the stage for a real Zookeeper alternative and, sure enough, &lt;a href="https://github.com/coreos/etcd"&gt;etcd&lt;/a&gt; was soon introduced by CoreOS. Besides being based on a simpler consensus algorithm, etcd is overall simpler. It's written in Go and lets you use HTTP to interact with it. I was extremely excited by etcd and used it in the initial architecture for Flynn.&lt;/p&gt;

&lt;p&gt;Today there's also &lt;a href="http://www.consul.io/"&gt;Consul&lt;/a&gt; by Hashicorp, which builds on the ideas of etcd. I specifically explore Consul and lock servers more in my next post.&lt;/p&gt;

&lt;h2 id="service-discovery-solutions"&gt;Service Discovery Solutions&lt;/h2&gt;

&lt;p&gt;Both Consul and etcd advertise themselves as service discovery solutions. Unfortunately, that's not entirely true. They're great service &lt;em&gt;directories&lt;/em&gt;. But this is just part of a service discovery solution. So what's missing?&lt;/p&gt;

&lt;p&gt;We're missing exactly how to get all our software, whether custom services or off-the-shelf software, to integrate with and use the service directory. This is particularly interesting to the Docker community, which ideally has portable solutions for anything that can run in a container.&lt;/p&gt;

&lt;p&gt;A comprehensive solution to service discovery will have three legs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A consistent (ideally), highly available service &lt;em&gt;directory&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;A mechanism to &lt;em&gt;register&lt;/em&gt; services and monitor service &lt;em&gt;health&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;A mechanism to &lt;em&gt;lookup and connect&lt;/em&gt; to services&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We've got good technology for the first leg, but the remaining legs, despite how they sound, aren't exactly trivial. Especially when ideally you want them to be automatic and "non-invasive." In other words, they work with non-cooperating software, not designed for a service discovery system. Luckily, Docker has both increased the demand for these properties and makes them easier to solve.&lt;/p&gt;

&lt;p&gt;In a world where you have lots of services coming and going across many hosts, service discovery is extremely valuable, if not necessary. Even in smaller systems, a solid service discovery system should reduce the effort in configuring and connecting services together to nearly nothing. Adding the responsibility of service discovery to configuration management tools, or using a centralized message queue for everything are all-to-common alternatives that we know just don't scale.&lt;/p&gt;

&lt;p&gt;My goal with these posts is to help you understand and arrive at a good idea of what a service discovery system should actually encompass. The next few posts will take a deeper look at each of the above mentioned legs, touching on various approaches, and ultimately explaining what I ended up doing for my soon-to-be-released project, Consulate.&lt;/p&gt;

</content>
  </entry>
</feed>

</main>



    <footer>
      <div class="container clearfix">
        &copy; 2016 Jeff Lindsay
      </div>
    </footer>

  </div>
  <script src="/javascripts/all.js"></script>
  <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>
        <script type="text/javascript">
        try {
        var pageTracker = _gat._getTracker("UA-6824126-1");
        pageTracker._trackPageview();
        } catch(err) {}</script>
  </body>
</html>
